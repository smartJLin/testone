## 函数
>函数的定义：一堆特定代码的集合体，它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性，一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏
> 函数就是一个功能，并且具备复用性

> 声明函数和使用函数

```js
// 声明函数
function 函数名 (){
    // 函数体
}

// 调用函数
函数名();
```
特点说明：
+ 函数默认不会执行 必须通过函数名()调用才会执行
+ 函数的命名尽量遵守 动词或者动词+名词的方式 这样函数的作用一目了然

```js
function greet(){
    console.log(Hi);
}

sayHi();
```
思考：

```js
1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
```
## 函数传参
函数的参数极大的提高了函数的灵活性

> 在声明函数的小括号里面写的数值我们称之为形式参数  形式参数的作用就是声明了两个变量 参数与参数之间用逗号隔开
> 在调用函数的小括号里面写的数值我们称之为实际参数  实际参数的作用就是给形式参数赋值，参数与参数之间用逗号隔开

形参：声明变量
实参：给变量赋值


```javascript
//带参数的函数声明
function 函数名(形参1, 形参2, 形参...){
  //函数体
}

//带参数的函数调用
函数名(实参1, 实参2, 实参3);
```

思考：

```js
1. 计算1-n之间所有数的和
2. 计算m-n之间所有数的和
3. 班级有五个学生  计算着五个学生的总成绩
```

## 函数的返回值
> 通俗的讲就是这个函数执行完毕之后的结果
> 在直观一点就是函数调用之后的值  默认是undefined

```js

    function doSomething(){
        // doing
        return result;
    }

    var jieguo = doSomething();
```

函数的返回值不是必要的，一般用于函数执行完毕之后产生一个结果 这个结果在其他地方需要使用的时候就需要返回值，如果当前函数没有返回值
浏览器会默认返回一个undefined

函数三要素：函数名，参数，返回值

思考1：

```javascript
1. 求任意半径的圆的面积
2. 求任意半径的圆的周长
3. 求任意2个数中的最大值
```
思考2：

```javascript
1. 求任意数组中的最大值
2. 求任意数组中的最小值
3. 翻转任意数组，返回一个新的数组
4. 对任意数组从小到大排序
```
## 函数高级知识
> 函数内部是可以继续调用其他函数的

```javascript
function fn1() {
    console.log("fn1开始...");
    fn2();
    console.log("fn1结束...");
}

function fn2 () {
    console.log("执行fn2的代码");
	console.log("执行fn2的代码");
	console.log("执行fn2的代码");
}

//在函数1中调用了函数2
fn1();
```

断点调试：

```javascript
1.	F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.	F10：单步调试（跳过函数调用）
3.	F11：单步调试（进入函数调用）
4.	shift+F11：跳出函数调用
```

思考：

```javascript
1. 求阶乘
2. 求阶乘的和
3. 求任意3个数中的最大值
```
## 参数的详解
1. 两个相同的函数后面的会覆盖前面的函数
2. 在Javascript中 实参的个数和形参的个数可以不一样
    + 如果实参过多 那么多余的实参会被忽略
    + 如果形参过多 会自动填上undefined

## 返回值的详解
1. 函数的返回值就是fn();的结果  return多少 fn();就是多少
2. 函数碰到return就不会在往下执行了  函数的结束用return  break是用在循环里面的
3. return;的写法相当于return undefined;

思考:
```js
 改写数组去重
 求数组中的最大值和最小值，并且返回
 难点：返回两个值
```

## 作用域

> 作用域：变量起作用的区域

> 全局作用域：在script标签内，在函数外的区域，在全局作用域内定义的变量是全局变量，全局变量在任何地方都能访问到
> 局部作用域：在函数内部的区域，在函数内部定义的变量叫做局部变量,这个局部变量只有在当前函数内部才能访问。
> 隐式全局变量：没有用var声明的变量是全局变量（隐式全局）不要使用


## 预解析
> JS在真正执行之前，在JS运行之前 JS解析器会将JS代码预先解析  （将变量声明和函数声明提前）
> 如果遇到同名的函数和变量，函数优先。

思考：
```js
// 重名getcool的问题
getCool();

// var 会提前声明
console.log(a);
  var a = 1;
  function a() {
    console.log('aaaa');
  }
console.log(a);
```

面试题：
```javascript

//1.
var num = 10;
fn1();
function fn1() {
  console.log(num);
  var num = 20;
}

//2.
var a = 18;
fn2();
function fn2() {
    var b = 9;
    console.log(a);
    console.log(b);
}

//3.
fn3();
console.log(c);
console.log(b);
console.log(a);
function fn3() {
  var a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}


//4.
a();
function a (){
console.log(1);
}
var a = 1;
a();
console.log(a);
```

## 匿名函数
> 何为匿名函数  就是没有名字的函数

```js
function(){

}
```

匿名函数因为没有名字 所以没有办法直接使用
1.通过将匿名函数赋值给一个变量 我们将这个称之为函数表达式
函数表达式值会预解析前面的var 后面的值不会被解析
2.函数自执行
匿名函数();

函数可以避免全局变量的污染