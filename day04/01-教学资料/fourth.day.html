<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>fourth.day</title>
  <!-- <link rel="stylesheet" href="lib/css/monokai-sublime.css"> -->
  <link rel="stylesheet" href="lib/css/default.min.css">
  <link rel="stylesheet" href="lib/css/vs2015.css">
  <link rel="stylesheet" href="lib/css/zTreeStyle/zTreeStyle.css">
  <link rel="stylesheet" href="lib/css/base.css">
  <link rel="stylesheet" href="lib/css/index.css">
</head>

<body>
  <div style='width:25%;'>
    <ul id="tree" class="ztree" style='width:100%'>

    </ul>
  </div>
  <div id='readme' style='width:70%;margin-left:20%;'>
    <article class='markdown-body'><h2 id="-">函数</h2>
<blockquote>
<p>函数的定义：一堆特定代码的集合体，它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性，一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏
函数就是一个功能，并且具备复用性</p>
</blockquote>
<blockquote>
<p>声明函数和使用函数</p>
</blockquote>
<pre><code class="lang-js">// 声明函数
function 函数名 (){
    // 函数体
}

// 调用函数
函数名();
</code></pre>
<p>特点说明：</p>
<ul>
<li>函数默认不会执行 必须通过函数名()调用才会执行</li>
<li>函数的命名尽量遵守 动词或者动词+名词的方式 这样函数的作用一目了然</li>
</ul>
<pre><code class="lang-js">function greet(){
    console.log(Hi);
}

sayHi();
</code></pre>
<p>思考：</p>
<pre><code class="lang-js">1. 封装一个打招呼的函数
2. 封装一个函数，计算两个数的和
3. 封装一个函数，计算1-100之间所有数的和
</code></pre>
<h2 id="-">函数传参</h2>
<p>函数的参数极大的提高了函数的灵活性</p>
<blockquote>
<p>在声明函数的小括号里面写的数值我们称之为形式参数  形式参数的作用就是声明了两个变量 参数与参数之间用逗号隔开
在调用函数的小括号里面写的数值我们称之为实际参数  实际参数的作用就是给形式参数赋值，参数与参数之间用逗号隔开</p>
</blockquote>
<p>形参：声明变量
实参：给变量赋值</p>
<pre><code class="lang-javascript">//带参数的函数声明
function 函数名(形参1, 形参2, 形参...){
  //函数体
}

//带参数的函数调用
函数名(实参1, 实参2, 实参3);
</code></pre>
<p>思考：</p>
<pre><code class="lang-js">1. 计算1-n之间所有数的和
2. 计算m-n之间所有数的和
3. 班级有五个学生  计算着五个学生的总成绩
</code></pre>
<h2 id="-">函数的返回值</h2>
<blockquote>
<p>通俗的讲就是这个函数执行完毕之后的结果
在直观一点就是函数调用之后的值  默认是undefined</p>
</blockquote>
<pre><code class="lang-js">
    function doSomething(){
        // doing
        return result;
    }

    var jieguo = doSomething();
</code></pre>
<p>函数的返回值不是必要的，一般用于函数执行完毕之后产生一个结果 这个结果在其他地方需要使用的时候就需要返回值，如果当前函数没有返回值
浏览器会默认返回一个undefined</p>
<p>函数三要素：函数名，参数，返回值</p>
<p>思考1：</p>
<pre><code class="lang-javascript">1. 求任意半径的圆的面积
2. 求任意半径的圆的周长
3. 求任意2个数中的最大值
</code></pre>
<p>思考2：</p>
<pre><code class="lang-javascript">1. 求任意数组中的最大值
2. 求任意数组中的最小值
3. 翻转任意数组，返回一个新的数组
4. 对任意数组从小到大排序
</code></pre>
<h2 id="-">函数高级知识</h2>
<blockquote>
<p>函数内部是可以继续调用其他函数的</p>
</blockquote>
<pre><code class="lang-javascript">function fn1() {
    console.log(&quot;fn1开始...&quot;);
    fn2();
    console.log(&quot;fn1结束...&quot;);
}

function fn2 () {
    console.log(&quot;执行fn2的代码&quot;);
    console.log(&quot;执行fn2的代码&quot;);
    console.log(&quot;执行fn2的代码&quot;);
}

//在函数1中调用了函数2
fn1();
</code></pre>
<p>断点调试：</p>
<pre><code class="lang-javascript">1.    F8：跳到下一个断点，如果后面没有断点了，那么代码直接执行完。
2.    F10：单步调试（跳过函数调用）
3.    F11：单步调试（进入函数调用）
4.    shift+F11：跳出函数调用
</code></pre>
<p>思考：</p>
<pre><code class="lang-javascript">1. 求阶乘
2. 求阶乘的和
3. 求任意3个数中的最大值
</code></pre>
<h2 id="-">参数的详解</h2>
<ol>
<li>两个相同的函数后面的会覆盖前面的函数</li>
<li>在Javascript中 实参的个数和形参的个数可以不一样<ul>
<li>如果实参过多 那么多余的实参会被忽略</li>
<li>如果形参过多 会自动填上undefined</li>
</ul>
</li>
</ol>
<h2 id="-">返回值的详解</h2>
<ol>
<li>函数的返回值就是fn();的结果  return多少 fn();就是多少</li>
<li>函数碰到return就不会在往下执行了  函数的结束用return  break是用在循环里面的</li>
<li>return;的写法相当于return undefined;</li>
</ol>
<p>思考:</p>
<pre><code class="lang-js"> 改写数组去重
 求数组中的最大值和最小值，并且返回
 难点：返回两个值
</code></pre>
<h2 id="-">作用域</h2>
<blockquote>
<p>作用域：变量起作用的区域</p>
</blockquote>
<blockquote>
<p>全局作用域：在script标签内，在函数外的区域，在全局作用域内定义的变量是全局变量，全局变量在任何地方都能访问到
局部作用域：在函数内部的区域，在函数内部定义的变量叫做局部变量,这个局部变量只有在当前函数内部才能访问。
隐式全局变量：没有用var声明的变量是全局变量（隐式全局）不要使用</p>
</blockquote>
<h2 id="-">预解析</h2>
<blockquote>
<p>JS在真正执行之前，在JS运行之前 JS解析器会将JS代码预先解析  （将变量声明和函数声明提前）
如果遇到同名的函数和变量，函数优先。</p>
</blockquote>
<p>思考：</p>
<pre><code class="lang-js">// 重名getcool的问题
getCool();

// var 会提前声明
console.log(a);
  var a = 1;
  function a() {
    console.log(&#39;aaaa&#39;);
  }
console.log(a);
</code></pre>
<p>面试题：</p>
<pre><code class="lang-javascript">
//1.
var num = 10;
fn1();
function fn1() {
  console.log(num);
  var num = 20;
}

//2.
var a = 18;
fn2();
function fn2() {
    var b = 9;
    console.log(a);
    console.log(b);
}

//3.
fn3();
console.log(c);
console.log(b);
console.log(a);
function fn3() {
  var a = b = c = 9;
  console.log(a);
  console.log(b);
  console.log(c);
}


//4.
a();
function a (){
console.log(1);
}
var a = 1;
a();
console.log(a);
</code></pre>
<h2 id="-">匿名函数</h2>
<blockquote>
<p>何为匿名函数  就是没有名字的函数</p>
</blockquote>
<pre><code class="lang-js">function(){

}
</code></pre>
<p>匿名函数因为没有名字 所以没有办法直接使用
1.通过将匿名函数赋值给一个变量 我们将这个称之为函数表达式
函数表达式值会预解析前面的var 后面的值不会被解析
2.函数自执行
匿名函数();</p>
<p>函数可以避免全局变量的污染</p>
</article>
  </div>
</body>
</html>
<script type="text/javascript" src="lib/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="lib/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="lib/js/ztree_toc.min.js"></script>
<script type="text/javascript" src="lib/js/toc_conf.js"></script>
<script src="lib/js/highlight.min.js"></script>
<script>
  $(document).ready(function () {
    // 代码高亮的js代码
    hljs.initHighlightingOnLoad();

    //生成侧边栏的代码
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</script>